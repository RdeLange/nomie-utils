{"version":3,"file":"index.es.js","sources":["../src/time/time.ts","../src/tokenize-note/tokenize-note.ts"],"sourcesContent":["export default {\n  padTime(t: string) {\n    return (t + '').length === 1 ? (t + '').padStart(2, '0') : t\n  },\n  // Seconds to Time Chunk \"03:30:30\"\n  secondsToTime(secondsStr: string | number): string {\n    let _seconds =\n      typeof secondsStr == 'string' ? parseInt(secondsStr) : secondsStr\n    let seconds = ''\n    let minutes = Math.floor(_seconds / 60).toString()\n    let hours = ''\n    if (parseInt(minutes) > 59) {\n      hours = this.padTime(Math.floor(parseInt(minutes) / 60).toString())\n      minutes = this.padTime(\n        (parseInt(minutes) - parseInt(hours) * 60).toString()\n      )\n    }\n    seconds = this.padTime(Math.floor(_seconds % 60).toString())\n    minutes = this.padTime(minutes)\n\n    if (hours !== '') {\n      return `${this.padTime(hours)}:${minutes}:${seconds}`\n    } else {\n      return `00:${minutes}:${seconds}`\n    }\n  },\n  msToSecond(ms: number) {\n    return ms / 1000\n  },\n  timestringToSeconds(timestring: string): number {\n    let tsa = timestring.split(':')\n    return this.unitsToSeconds(tsa[0], tsa[1], tsa[2])\n  },\n  unitsToSeconds(hour: string, minutes: string, seconds: string): number {\n    let s = 0\n    s = (parseInt(hour) || 0) * 60 * 60\n    s = s + (parseInt(minutes) || 0) * 60\n    s = s + (parseInt(seconds) || 0)\n    return s\n  },\n}\n","import time from '../time/time'\n\nexport interface WordPart {\n  word: string\n  remainder: string\n}\nexport interface Token {\n  id: string\n  raw: string // Raw word\n  prefix: string // #,@,+\n  type: string // type of trackableElement\n  value: string | number // value of the tracker\n  remainder: string //any trailing words\n}\n\nexport interface DeepResults {\n  trackers: Array<any>\n  context: Array<any>\n  people: Array<any>\n  tokens: Array<Token>\n}\n\n/**\n * getValueString\n * Returns a value string from #tracker(value)\n * @param {String} word\n */\nfunction getValueString(word: string): number {\n  const wordSplit = word.split('(')\n  let value = wordSplit.length == 2 ? wordSplit[1].replace(')', '') : '1'\n  value = value.length ? value : '1'\n  return parseStringValue(value)\n}\n\n/**\n * Parse String Value\n * Convert a string into a value, or a time string 01:03:44 into seconds\n * @param valueStr String\n */\nfunction parseStringValue(valueStr: string): number {\n  if (valueStr.split('.').length == 2) {\n    return parseFloat(valueStr)\n  } else if (valueStr.search(':') > -1) {\n    return time.timestringToSeconds(valueStr)\n  } else {\n    return parseInt(valueStr)\n  }\n}\n\n/**\n * Scrub\n * Removes common word ending characters\n * @param {String} word\n */\nfunction scrub(word: string): WordPart {\n  const cleanedWord: string = word.replace(/(\\'|\\,|\\.|\\!|â€™|\\?|:)/gi, '')\n  return {\n    word: cleanedWord,\n    remainder: word.replace(cleanedWord, '')\n  }\n}\n\n/**\n * toToken\n * Creates a payload that can be turned into a\n * @param {String} type tracker,context,person,generic\n * @param {String} word\n * @param {String} value\n * @param {String} remainder\n */\nconst prefixes = { context: '+', person: '@', tracker: '#' }\n\nfunction toToken(\n  type: string,\n  word: any,\n  value: any = '',\n  remainder: any = '',\n  raw?: string | any\n): Token {\n  const prefix = prefixes[type] || ''\n  const id = (word.search(/\\(/) > -1\n    ? word.replace(prefix, '').split('(')[0]\n    : word.replace(prefix, '')\n  ).toLowerCase()\n  raw = raw || word || ''\n  return {\n    id,\n    raw, // Raw word\n    prefix, // #,@,+\n    type, // type of trackableElement\n    value, // value of the tracker\n    remainder //any trailing words\n  }\n}\n\n/**\n * Parse\n * parses a string and returns an array of\n * elements\n * @param {String} str\n */\nfunction parse(str: string): Array<Token> {\n  // Split it into an array of lines\n  let lines = str.split(/\\r?\\n/)\n  let final: Array<Token> = []\n  // Loop over each line\n  lines.forEach((line) => {\n    // Extract\n    let tokens = parseStr(line)\n    tokens.forEach((token: Token) => {\n      final.push(token)\n    })\n    // Add the line Break\n    if (lines.length > 1) {\n      final.push(toToken('line-break', ''))\n    }\n  })\n  // Return parsed note\n  return final\n}\n\n/**\n * Sum all numbers in an array\n * @param nums Array\n */\nfunction sum(nums: Array<number>): number {\n  return nums.reduce(function (a, b) {\n    return a + b\n  }, 0)\n}\n/**\n * Average all numbers in an array\n * @param nums Array\n */\nfunction average(nums: Array<number>): number {\n  const total = nums.reduce((acc, c) => acc + c, 0)\n  return total / nums.length\n}\n\n/**\n * Deep Tokenization\n * Parse, and calculate base stats\n * @param nums Array\n */\nfunction deep(str: string): DeepResults {\n  let tokens: Array<Token> = parse(str)\n  let response = stats(tokens)\n  response.tokens = tokens\n  return response\n}\n\n/**\n * Parse a Line to an array.\n * @param {String} str\n */\nfunction parseStr(str: string): any {\n  let wordArray = str.trim().split(' ')\n  return (\n    // Split on the space\n    wordArray\n      .map((word: string) => {\n        // Loop over each word\n        let scrubbed = scrub(word) // Scrub it clean\n        let valueStr = getValueString(word)\n        let firstChar = word.trim().substr(0, 1)\n        // switch on first character\n        if (firstChar === '#') {\n          if (word.match(/\\d\\d:\\d\\d/)) {\n            // if it's a timer\n            return toToken(\n              'tracker',\n              word,\n              valueStr,\n              scrubbed.remainder.replace(word, '')\n            )\n          } else {\n            return toToken(\n              'tracker',\n              scrubbed.word,\n              valueStr,\n              scrubbed.remainder.replace(word, '')\n            )\n          }\n        } else if (firstChar === '@') {\n          return toToken(\n            'person',\n            scrubbed.word.toLowerCase(),\n            valueStr,\n            scrubbed.remainder\n          )\n        } else if (firstChar === '+') {\n          return toToken('context', scrubbed.word, valueStr, scrubbed.remainder)\n        } else if (word.search(/https:|http:/) > -1) {\n          return toToken(\n            'link',\n            word.trim().replace(/(https|http):\\/\\//gi, ''),\n            null,\n            null,\n            word.trim()\n          )\n        } else if (word) {\n          return {\n            id: `${word}`,\n            type: 'generic',\n            raw: `${word}`,\n            prefix: null,\n            remainder: null\n          }\n        }\n        return null\n      })\n      .filter((word) => word)\n  )\n} // end parse string\n\n/**\n * Stats\n * Generate stats for a set of tokens\n * @param tokens Array\n */\nfunction stats(tokens: Array<Token>): DeepResults {\n  let map: any = {\n    trackers: {},\n    people: {},\n    context: {}\n  }\n  // Loop over tokens\n  tokens.forEach((token: Token) => {\n    // If its a tracker - do tracker things\n    if (token.type == 'tracker') {\n      map.trackers[token.id] =\n        map.trackers[token.id] || Object.assign(token, {})\n      map.trackers[token.id].values = map.trackers[token.id].values || []\n      map.trackers[token.id].values.push(token.value)\n    } else {\n      // Map person to people if needed\n      let type = token.type == 'person' ? 'people' : token.type\n      // Setup map for type\n      map[type] = map[type] || {}\n      map[type][token.id] = map[type][token.id] || Object.assign(token, {})\n      map[type][token.id].values = map[type][token.id].values || []\n      map[type][token.id].values.push(1)\n    }\n  })\n\n  // Create a Map for Results\n  let results: any = {\n    trackers: [],\n    context: [],\n    people: []\n  }\n\n  // Loop over the map to do final filtering\n  Object.keys(map).forEach((type) => {\n    let items = map[type]\n    // Loop over items for this type\n    results[type] = Object.keys(items).map((id) => {\n      let token = items[id]\n      token.sum = sum(token.values)\n      token.avg = average(token.values)\n      return token\n    })\n  })\n\n  let response = results\n  response.words = tokens.length\n\n  return response\n}\n\nexport const tokenizeDeep = deep\nexport const tokenize = function (str: string = ''): Array<Token> {\n  return parse(str)\n}\n"],"names":[],"mappings":"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"}